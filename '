import cmd
import queue
import sys
import threading
import time

import key_listener as kl
from ib_client import IBClient, qu_ask, qu_bid, qu_contract, qu_orderstatus
from rich.console import Console
from trade import STAGE, Trade

cs = Console()
cs.clear()

## Must instantiate the client first because it carries the console instance
client = IBClient()
client.connect("127.0.0.1", 7500, clientId=1001)
## delay market data
## set to 1 for real-time market data
client.reqMarketDataType(1)
# ibclient_thread = threading.Thread(target=start_ib_client, args=(client,), daemon=True)
ibclient_thread = threading.Thread(target=client.run, daemon=True)
ibclient_thread.start()
# Wait for next valid order ID to give time for thread to start up
while client.order_id is None:
    time.sleep(0.5)

asset = cs.input("Define asset: ")
t = Trade(symbol=asset, position=10)
t.define_contract()

cmd = cmd.Cmd(client=client, trade=t)

client.nextId()
client.reqContractDetails(client.order_id, contract=t.contract)
# get method is blocking
c = qu_contract.get(timeout=5)
t.conid = c["conId"]
t.define_contract()
# request market data
client.reqMktData(client.order_id, t.contract, "", False, False, [])
t.stage = STAGE.ENTRY

while True:
    # TODO: capture error message
    # TODO: capture order history
    match t.stage:
        case STAGE.ENTRY:
            try:
                msg = qu_ask.get(timeout=2)
                cs.print(f"buy {t.symbol} at {msg['price']}? y/n ", end="")
                input = kl.get_single_key()
                # cs.print("\n")
                if input == "y":
                    cmd.buy_limit(msg["price"])
                    t.stage = STAGE.CHECK_ENTRY
                else:
                    # time.sleep(1)
                    continue
            except queue.Empty:
                # TODO: provide the option to cancel the order and exit app
                cs.print("ask queue empty")
                continue
        case STAGE.CHECK_ENTRY:
            try:
                ordstat = qu_orderstatus.get(timeout=2)
                if ordstat["status"] == "Filled":
                    cs.print(f"{client.order_id} Status: {ordstat['status']} ")
                    cs.print(
                        f"{client.order_id} Entry Price: {ordstat['avgFillPrice']} "
                    )
                    t.entry_price = ordstat["avgFillPrice"]
                    t.stage = STAGE.HOLD
                else:
                    cs.print("order not filled")
                    cs.print(ordstat)
                    time.sleep(1)
                    continue
            except queue.Empty:
                cs.print("order status queue empty")
                continue
        case STAGE.HOLD:
            try:
                msg = qu_bid.get(timeout=2)
                cs.print(f"sell {t.symbol} at {msg['price']}? y/n ", end="")
                input = kl.get_single_key()
                # cs.print("\n")
                if input == "y":
                    cmd.sell_limit(msg["price"])
                    t.stage = STAGE.CHECK_EXIT
                else:
                    time.sleep(1)
                    continue
            except queue.Empty:
                cs.print("bid queue empty")
                continue
        case STAGE.CHECK_EXIT:
            try:
                ordstat = qu_orderstatus.get(timeout=2)
                if ordstat["status"] == "Filled":
                    cs.print(f"{client.order_id} Status: {ordstat['status']} ")
                    cs.print(
                        f"{client.order_id} Entry Price: {ordstat['avgFillPrice']} "
                    )
                    t.exit_price = ordstat["avgFillPrice"]
                    t.stage = STAGE.DISCONNECT
                else:
                    cs.print("order not filled")
                    cs.print(ordstat)
                    time.sleep(1)
                    continue
            except queue.Empty:
                cs.print("order status queue empty")
                continue
        case STAGE.DISCONNECT:
            s = cs.input("Shutdown Algo? (y/n)")
            if s == "y":
                client.disconnect()
                cs.print("Disconnecting from TWS...")
                break

ibclient_thread.join()
sys.exit(0)
